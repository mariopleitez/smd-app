create table if not exists public.cookbooks (
  id bigint generated by default as identity primary key,
  owner_user_id uuid not null references auth.users (id) on delete cascade,
  name text not null,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint cookbooks_name_not_empty check (char_length(trim(name)) > 0)
);

create table if not exists public.recipes (
  id bigint generated by default as identity primary key,
  owner_user_id uuid not null references auth.users (id) on delete cascade,
  name text not null,
  description text not null default '',
  main_photo_url text,
  additional_photos text[] not null default '{}',
  steps jsonb not null default '[]'::jsonb,
  instructions text,
  is_public boolean not null default false,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  constraint recipes_name_not_empty check (char_length(trim(name)) > 0)
);

create table if not exists public.cookbook_recipes (
  cookbook_id bigint not null references public.cookbooks (id) on delete cascade,
  recipe_id bigint not null references public.recipes (id) on delete cascade,
  created_at timestamptz not null default now(),
  primary key (cookbook_id, recipe_id)
);

create index if not exists cookbooks_owner_idx
  on public.cookbooks (owner_user_id, created_at desc);

create index if not exists recipes_owner_idx
  on public.recipes (owner_user_id, created_at desc);

create index if not exists recipes_public_idx
  on public.recipes (is_public, created_at desc);

create index if not exists cookbook_recipes_recipe_idx
  on public.cookbook_recipes (recipe_id);

create or replace function public.set_updated_at_timestamp()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

drop trigger if exists trg_cookbooks_updated_at on public.cookbooks;
create trigger trg_cookbooks_updated_at
before update on public.cookbooks
for each row
execute function public.set_updated_at_timestamp();

drop trigger if exists trg_recipes_updated_at on public.recipes;
create trigger trg_recipes_updated_at
before update on public.recipes
for each row
execute function public.set_updated_at_timestamp();

alter table public.cookbooks enable row level security;
alter table public.recipes enable row level security;
alter table public.cookbook_recipes enable row level security;

grant select, insert, update, delete on table public.cookbooks to authenticated;
grant usage, select on sequence public.cookbooks_id_seq to authenticated;

grant select, insert, update, delete on table public.recipes to authenticated;
grant usage, select on sequence public.recipes_id_seq to authenticated;

grant select, insert, update, delete on table public.cookbook_recipes to authenticated;

drop policy if exists "cookbooks_select_public" on public.cookbooks;
create policy "cookbooks_select_public"
on public.cookbooks
for select
using (true);

drop policy if exists "cookbooks_insert_own" on public.cookbooks;
create policy "cookbooks_insert_own"
on public.cookbooks
for insert
with check (auth.uid() = owner_user_id);

drop policy if exists "cookbooks_update_own" on public.cookbooks;
create policy "cookbooks_update_own"
on public.cookbooks
for update
using (auth.uid() = owner_user_id)
with check (auth.uid() = owner_user_id);

drop policy if exists "cookbooks_delete_own" on public.cookbooks;
create policy "cookbooks_delete_own"
on public.cookbooks
for delete
using (auth.uid() = owner_user_id);

drop policy if exists "recipes_select_public_or_owner" on public.recipes;
create policy "recipes_select_public_or_owner"
on public.recipes
for select
using (is_public or auth.uid() = owner_user_id);

drop policy if exists "recipes_insert_own" on public.recipes;
create policy "recipes_insert_own"
on public.recipes
for insert
with check (auth.uid() = owner_user_id);

drop policy if exists "recipes_update_own" on public.recipes;
create policy "recipes_update_own"
on public.recipes
for update
using (auth.uid() = owner_user_id)
with check (auth.uid() = owner_user_id);

drop policy if exists "recipes_delete_own" on public.recipes;
create policy "recipes_delete_own"
on public.recipes
for delete
using (auth.uid() = owner_user_id);

drop policy if exists "cookbook_recipes_select_visible" on public.cookbook_recipes;
create policy "cookbook_recipes_select_visible"
on public.cookbook_recipes
for select
using (
  exists (
    select 1
    from public.recipes r
    where r.id = recipe_id
      and (r.is_public or r.owner_user_id = auth.uid())
  )
);

drop policy if exists "cookbook_recipes_insert_owner" on public.cookbook_recipes;
create policy "cookbook_recipes_insert_owner"
on public.cookbook_recipes
for insert
with check (
  exists (
    select 1
    from public.cookbooks c
    where c.id = cookbook_id
      and c.owner_user_id = auth.uid()
  )
  and exists (
    select 1
    from public.recipes r
    where r.id = recipe_id
      and r.owner_user_id = auth.uid()
  )
);

drop policy if exists "cookbook_recipes_delete_owner" on public.cookbook_recipes;
create policy "cookbook_recipes_delete_owner"
on public.cookbook_recipes
for delete
using (
  exists (
    select 1
    from public.cookbooks c
    where c.id = cookbook_id
      and c.owner_user_id = auth.uid()
  )
);
